#Autogenerated by ReportLab guiedit do not edit
import datetime
#from reportlab import xrange
from reportlab.lib.colors import PCMYKColor
from reportlab.graphics.charts.lineplots import LinePlot
from reportlab.graphics.shapes import Drawing, _DrawingEditorMixin, Rect, Group
from reportlab.graphics.widgets.markers import makeMarker
from reportlab.graphics.charts.axes import AxisLabelAnnotation, AxisLineAnnotation
from reportlab.graphics.charts.textlabels import Label
from utils import registerFonts
import itertools

class ProductChart(_DrawingEditorMixin,Drawing):
	def __init__(self,width=400,height=200,*args,**kw):
		Drawing.__init__(self,width,height,*args,**kw)
		self._add(self,Group(),name='bottomtitles',validate=None,desc=None)
		registerFonts()
		self.height      = 184
		self.width       = 457.622
		self._add(self,LinePlot(),name='chart',validate=None,desc=None)
		self.chart.y = 20
		self.chart.x = 30
		self.chart.width            = self.width - 2*self.chart.x
		self.chart.height           = self.height - self.chart.y - 28
		self.background       = Rect(0,0,self.width,self.height,strokeColor=None,fillColor=PCMYKColor(9.77,7.42,0,1.56))
		self.chart.y                = 40
		self._bottom_left = ''
		self._bottom_middle = 'Oct 2018'
		self._bottom_right = "*Manager's expectations"
		bt = self.bottomtitles
		bt.add(Label())
		bt.add(Label())
		bt.add(Label())
		bty = self.chart.y - 20
		btc = bt.contents
		self._dates = ['%s/%s/%s' % (d,m,y) for d,m,y in [s.split('/') for s in '05/04/2014 05/10/2014 05/04/2015 05/10/2015 05/04/2016 05/10/2016 05/04/2017'.split()]]
		self._data = [[1.0, 0.935, 0.9323, 0.9256, 0.9476, 0.978, ''], [1.0, 1.00555, 1.0110999999999999, 1.0166499999999998, 1.0221999999999998, 1.0277499999999997, '']]
		self._expectations = ['', u'In Line', u'Below', u'Ahead', u'In Line', u'In Line', u'In Line']
		darkblue = PCMYKColor(100,75,1.95,17.97)
		lightblue = PCMYKColor(100,0,0,0)
		self._grey = grey = PCMYKColor(0,0,0,70)
		btFontName = 'MuseoSans_500'
		btc[0].boxAnchor='nw'
		btc[0].x = self.chart.x
		btc[0].y = bty
		btc[0].fontName = btFontName
		btc[0].fillColor = darkblue
		btc[1].boxAnchor='n'
		btc[1].textAnchor='middle'
		btc[1].x = self.chart.x + self.chart.width*0.5
		btc[1].y = bty
		btc[1].fontName = btFontName
		btc[1].fillColor = lightblue
		btc[2].boxAnchor='ne'
		btc[2].textAnchor='middle'
		btc[2].x = self.chart.x+self.chart.width
		btc[2].y = bty
		btc[2].fontName = btFontName
		self._chartColors = darkblue, lightblue, grey 
		self.chart.lines.symbol = makeMarker('Circle')
		self.chart.lines.symbol.size = 8
		self.chart.yValueAxis.labelTextFormat = lambda v: '%.0f%%' % (100*v)
		self.chart.xValueAxis.visibleTicks            = 0
		self.chart.xValueAxis.labels.dx               = 1
		self.chart.xValueAxis.labels.dy               = -1
		self.chart.xValueAxis.labels.fontName         = 'MuseoSans_300'
		self.chart.xValueAxis.labels.fontSize         = 8
		self.chart.xValueAxis.labels.boxAnchor        = 'nw'
		self.chart.xValueAxis.labels.fillColor        = grey
		self.chart.yValueAxis.labels.fillColor        = grey
		self.chart.yValueAxis.avoidBoundSpace         = 15,15
		self.chart.yValueAxis.rangeRound='both'
		self.chart.yValueAxis.labels.fontName         = 'MuseoSans_300'
		self.chart.lineLabels.fontName         = 'MuseoSans_500'
		self.chart.lineLabels.fontSize         = 8
		self.chart.lineLabelNudge   = 0
		self.chart.lineLabels.dx               = 3

	def getContents(self):
		fix = lambda v: None if not isinstance(v,(float,int)) else v
		expectations = self._expectations
		data = [([fix(v) for v in V],cll,cc) for cll,cc,V in zip(('PRICE INC.\nDIVIDENDS %', 'NAV INC.\nDIVIDENDS%', 'BENCH %'),self._chartColors,self._data)]
		data = [_ for _ in data if _[0].count(None)<len(_[0])]
		cc = [_[2] for _ in data]
		cll = [_[1] for _ in data]
		data = [_[0] for _ in data]
		dates = self._dates
		dyear = lambda x:int(x.rsplit('/',1)[1])
		yn = dyear(dates[-1])
		i1 = max(sum((1 for _ in itertools.takewhile(lambda v:(yn - dyear(v))>5,dates))),0)
		i0 = max((sum(1 for _ in itertools.takewhile(lambda v:v is None,V)) for V in data))
		i0 = max(i0,i1)
		expectations = expectations[i0:]
		btc = self.bottomtitles.contents
		btc[0]._text  = self._bottom_left
		btc[2]._text  = 'Expected Exit: %s' % self._bottom_middle if self._bottom_middle else ''
		btc[1]._text  = '' #self._bottom_right if filter(None,expectations) else ''
		dates = dates[i0:]
		data = [V[i0:] for V in data]
		n = max((len(V) for V in data))
		data = [list(zip(range(len(V)),V)) for V in data]
		chart = self.chart
		chart.data  = data
		xA = chart.xValueAxis
		xA.valueMin = 0
		xA.valueMax = n+1
		xA.valueStep = 1
		_ = xA._labelTextFormat = [_.split('/',1)[1] for _ in dates]
		if len(_)>8: xA.labels.angle = -15
		A1 = [AxisLineAnnotation(i,start=chart.y-5,end=self.chart.y+self.chart.height+3,strokeDashArray=[2,2],strokeWidth=0.5,strokeColor=self._grey) for i in range(1,n+1)]
		#try:
		#	A2 = [AxisLabelAnnotation(i,_text='*'+t,dy=chart.height,fontSize=8,fillColor=self._grey,fontName='Helvetica',boxAnchor='ne',dx=-1) for i,t in enumerate(expectations) if t]
		#except:
		#	raise ValueError('trouble with i0=%s expectations=%r' % (i0,self._expectations))
		cnv =lambda x: "%.0f" % (100*x) if isinstance(x,(int,float)) else str(x)
		A2 = [AxisLabelAnnotation(i,_text='*'+cnv(t),dy=chart.height,fontSize=8,fillColor=self._grey,fontName='MuseoSans_300',boxAnchor='ne',dx=-1) for i,t in enumerate(expectations) if t]
		xA.annotations = A1 + A2
		for i,c in enumerate(cc): chart.lines[i].strokeColor = chart.lineLabels[i].fillColor = c
		chart.lineLabelFormat = lambda c,i,j,x,y: cll[i] if j==n-1 else ''
		chart.lineLabelFormat.__labelFmtEX__ = True
		VX = sorted([(d[-1][1],i) for i,d in enumerate(data)])
		CLD = len(VX)
		CLD = [('w',0)] if CLD==1 else ([('nw',-2),('sw',-2)] if CLD==2 else ([('nw',2),('w',0),('sw',-2)] if CLD==3 else []))
		for i,(v,j) in enumerate(VX): chart.lineLabels[j].boxAnchor = CLD[i][0]
		for i,(v,j) in enumerate(VX): chart.lineLabels[j].dy = CLD[i][1]
		return Drawing.getContents(self)

if __name__=="__main__": #NORUNTESTS
	ProductChart().save(formats=['pdf'],outDir='.',fnRoot=None)
